
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # File used to perform the benchmarking the algorithms.
> 
> # Packages ----------------------------------------------------------------
> library(Rcpp)
> library(data.table)
> library(ggplot2)
> library(parallel)
> 
> # functions to benchmark
> library(pcaPP) # cor.fk
> sourceCpp("src/ms.cpp")   # for Knight's extended alg.
> sourceCpp("src/dac_seq.cpp")  # divide-and-conquer alg.
> sourceCpp("src/bf.cpp")   # brute force alg.
> source("functions.R")       # wrappers (performs re-ordering if necessary)
> 
> 
> # Benchmark ---------------------------------------------------------------
> num_rep <- 100
> taus <- c(0, .25, .5, .75, 1)
> ks <- 8:18 # (n = 2^k)
> ps <- seq(2,10,2) # dimensions considered
> ps_sub <- ps[c(1,length(ps))] # dimensions considered for bf alg.
> 
> sim_grid <- expand.grid(rep_id = 1:num_rep, tau = taus, k = ks)
> sim_grid$n <- 2^sim_grid$k
> sim_grid$rho <- sin(sim_grid$tau*pi/2)
> cat("Number of row in sim_grid: ", nrow(sim_grid), "\n")
Number of row in sim_grid:  5500 
> 
> ns <- 2^ks
> 
> for(x in seq_along(ks)){
+   times <- mclapply(which(sim_grid$k == ks[x]), \(s){
+     
+     cat(".\n")
+     
+     rep_id <- sim_grid[s,]$rep_id
+     n <- sim_grid[s,]$n
+     k <- sim_grid[s,]$k
+     tau <- sim_grid[s,]$tau
+     rho <- sim_grid[s,]$rho
+     
+     set.seed(34*s)
+     X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n*10, 0, sqrt(1-rho)), n, 10))
+     
+     # very fast, needs many replications to get a good estimate
+     time_knight_o <- system.time(replicate(100, cor.fk(X[,1:2])))[[3]]/100
+     time_knight_e <- system.time(replicate(100, taujack_ms(X[,1:2])))[[3]]/100
+     
+     # still fast, but much less so (unless tau=1)
+     time_dac <- numeric(length(ps))
+     for(r in seq_along(ps)){
+       K <- ifelse(tau == 1 | k <= 12, 50, 5)
+       time_dac[r] <- system.time(replicate(K, taujack_dac(X[,1:ps[r]], thresh=25L)))[[3]]/K
+     }
+     
+     # not fast, unless n is small
+     time_bf <- as.numeric(c(NA, NA))
+     if(k <= 15){
+       for(r in c(1,2)){
+         if(k <= 12){
+           K <- 10
+         }else{
+           K <- 1
+         }
+         time_bf[r] <- system.time(replicate(K, taujack_bf(X[,1:ps_sub[r]], seq = T)))[[3]]/K
+       }
+     }
+     
+     dt <- data.table(rep_id=rep_id, n=n, tau=tau, rho=rho, p = c(2, 2, ps, ps_sub),
+                      fun = c("Knight (original, KO)", "Knight (extended, KE)",
+                              rep(c("divide-and-conquer (DAC)"), each=length(ps)),
+                              rep(c("brute force (BF)"), each=length(ps_sub))),
+                      time = c(time_knight_o, time_knight_e, time_dac, time_bf))
+     
+     return(dt)
+   }, mc.cores = 12) |> rbindlist()
+   
+   fwrite(times, paste0("benchmark/times", x, ".csv"))
+ }
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

 *** caught segfault ***
address 0x556808ecfa40, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x5568077876e0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x556808441de0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x556806d41420, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.

 *** caught segfault ***
address 0x556806d41420, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x556806d41420, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x556808441de0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x556806d41420, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x5568075b98f0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.

 *** caught segfault ***
address 0x5568075b98f0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x556808e41ba0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x556808e41ba0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

 *** caught segfault ***
address 0x556e6feaabb0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

 *** caught segfault ***
address 0x556e7584c2b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.

 *** caught segfault ***
address 0x556e74375380, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.
.
.
.

 *** caught segfault ***
address 0x556e7fc5ea10, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.
.

 *** caught segfault ***
address 0x556e7da831b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

 *** caught segfault ***
address 0x556e7c5ac950, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.

 *** caught segfault ***
address 0x55680d6fb8b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x55680d6fb8b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.
.

 *** caught segfault ***
address 0x55680d6fb8b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...

 *** caught segfault ***
address 0x55680d6fb8b0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x55680d6fb8c0, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
.

 *** caught segfault ***
address 0x556807cff940, cause 'memory not mapped'

Traceback:
 1: .Call(<pointer: 0x7f6c4a2d0080>, X, thresh, brute_force)
 2: dac_seq(X, thresh = thresh, brute_force = F)
 3: taujack_dac(X[, 1:ps[r]], thresh = 25L)
 4: FUN(X[[i]], ...)
 5: lapply(X = X, FUN = FUN, ...)
 6: sapply(integer(n), eval.parent(substitute(function(...) expr)),     simplify = simplify)
 7: replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L))
 8: system.time(replicate(K, taujack_dac(X[, 1:ps[r]], thresh = 25L)))
 9: FUN(X[[i]], ...)
10: lapply(X = S, FUN = FUN, ...)
11: doTryCatch(return(expr), name, parentenv, handler)
12: tryCatchOne(expr, names, parentenv, handlers[[1L]])
13: tryCatchList(expr, classes, parentenv, handlers)
14: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call, nlines = 1L)        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
15: try(lapply(X = S, FUN = FUN, ...), silent = TRUE)
16: sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE))
17: FUN(X[[i]], ...)
18: lapply(seq_len(cores), inner.do)
19: mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12)
20: rbindlist(mclapply(which(sim_grid$k == ks[x]), function(s) {    cat(".\n")    rep_id <- sim_grid[s, ]$rep_id    n <- sim_grid[s, ]$n    k <- sim_grid[s, ]$k    tau <- sim_grid[s, ]$tau    rho <- sim_grid[s, ]$rho    set.seed(34 * s)    X <- (rnorm(n, 0, sqrt(rho)) + matrix(rnorm(n * 10, 0, sqrt(1 -         rho)), n, 10))    time_knight_o <- system.time(replicate(100, cor.fk(X[, 1:2])))[[3]]/100    time_knight_e <- system.time(replicate(100, taujack_ms(X[,         1:2])))[[3]]/100    time_dac <- numeric(length(ps))    for (r in seq_along(ps)) {        K <- ifelse(tau == 1 | k <= 12, 50, 5)        time_dac[r] <- system.time(replicate(K, taujack_dac(X[,             1:ps[r]], thresh = 25L)))[[3]]/K    }    time_bf <- as.numeric(c(NA, NA))    if (k <= 15) {        for (r in c(1, 2)) {            if (k <= 12) {                K <- 10            }            else {                K <- 1            }            time_bf[r] <- system.time(replicate(K, taujack_bf(X[,                 1:ps_sub[r]], seq = T)))[[3]]/K        }    }    dt <- data.table(rep_id = rep_id, n = n, tau = tau, rho = rho,         p = c(2, 2, ps, ps_sub), fun = c("Knight (original, KO)",             "Knight (extended, KE)", rep(c("divide-and-conquer (DAC)"),                 each = length(ps)), rep(c("brute force (BF)"),                 each = length(ps_sub))), time = c(time_knight_o,             time_knight_e, time_dac, time_bf))    return(dt)}, mc.cores = 12))
An irrecoverable exception occurred. R is aborting now ...
Warning messages:
1: In mclapply(which(sim_grid$k == ks[x]), function(s) { :
  scheduled cores 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 did not deliver results, all values of the jobs will be affected
2: In fwrite(times, paste0("benchmark/times", x, ".csv")) :
  Input has no columns; creating an empty file at 'benchmark/times10.csv' and exiting.
3: In mclapply(which(sim_grid$k == ks[x]), function(s) { :
  scheduled cores 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 did not deliver results, all values of the jobs will be affected
4: In fwrite(times, paste0("benchmark/times", x, ".csv")) :
  Input has no columns; creating an empty file at 'benchmark/times11.csv' and exiting.
> 
> proc.time()
      user     system    elapsed 
397212.494    620.806  36396.320 
